# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: Java CI/CD with Maven

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
    - name: checkout repo
      uses: actions/checkout@v4
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    - name: Build with Maven
      run: mvn -B package --file pom.xml
  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - run: echo 'Тут будут тесты прогонятся, когда эти тесты завезут :) '

  deploy:
    name: Deploy to production via Docker Compose
    runs-on: self-hosted # Запускаем на раннере, который настроили до этого.
    needs: test # Запускаем только если джоба test прошла успешно
    env: # Пробрасываем секреты в среду шага deploy
      BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
      DB_URL: ${{ secrets.DB_URL }}
      DB_USERNAME: ${{ secrets.DB_USERNAME }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      OPEN_AI_TOKEN: ${{ secrets.OPEN_AI_TOKEN }}
      POSTGRES_DB: ${{ secrets.POSTGRES_DB }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Генерируем .env
      - name: Generate .env file
        run: |
          cat <<EOF > .env
          BOT_TOKEN=${BOT_TOKEN}
          DB_URL=${DB_URL}
          DB_USERNAME=${DB_USERNAME}
          DB_PASSWORD=${DB_PASSWORD}
          OPEN_AI_TOKEN=${OPEN_AI_TOKEN}
          POSTGRES_DB=${POSTGRES_DB}
          POSTGRES_USER=${DB_USERNAME}
          POSTGRES_PASSWORD=${DB_PASSWORD}
          EOF

      # Рендерим application.tpl.tpl из шаблона
      - name: Render application.tpl.tpl
        run: |
          envsubst < application.properties.tpl > application.properties

      - name: Cleanup Docker
        run: |
          docker builder prune --all --force
          docker image prune --all --force
          docker container prune --force
          docker volume prune --force

      - name: Build & deploy via docker-compose
        run: docker compose up -d --build --pull always --force-recreate

      - name: Connect app to shared_db_net
        run:
            # Определяем id запущенного контейнера сервиса "app"
            CONTAINER_ID=$(docker compose ps -q app)
            
            # Создаём сеть, если её нет
            docker network create shared_db_net || true
            
            # Подключаем контейнер к сети с alias=db
            docker network connect --alias db shared_db_net $CONTAINER_ID